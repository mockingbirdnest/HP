##TEMPLATE-NAME 'C# - Calitha Engine, Interface Based'
##LANGUAGE 'C#'
##ENGINE-NAME 'Calitha GOLD Parser Engine'
##AUTHOR 'Pascal Leroy' 
##FILE-EXTENSION 'cs'
##NOTES
This template creates the constants for symbols and rules and a custom parser
class that acts as a template for parsing any source.  When a string is being
parsed, an object that implements the I...Actions interface is updated and it is
returned by the Parse method.  The code to deal with the reductions and other 
events must be provided by the class that implements I...Actions.
##END-NOTES
##ID-CASE UPPERCASE
##ID-SEPARATOR '_'
##ID-SYMBOL-PREFIX 'Symbol'
##ID-RULE-PREFIX 'Rule'

using System;
using System.IO;
using System.Runtime.Serialization;
using com.calitha.goldparser.lalr;
using com.calitha.commons;

namespace com.calitha.goldparser
{

    [Serializable()]
    public class SymbolException : System.Exception
    {
        public SymbolException(string message) : base(message)
        {
        }

        public SymbolException(string message,
            Exception inner) : base(message, inner)
        {
        }

        protected SymbolException(SerializationInfo info,
            StreamingContext context) : base(info, context)
        {
        }

    }

    [Serializable()]
    public class RuleException : System.Exception
    {

        public RuleException(string message) : base(message)
        {
        }

        public RuleException(string message,
                             Exception inner) : base(message, inner)
        {
        }

        protected RuleException(SerializationInfo info,
                                StreamingContext context) : base(info, context)
        {
        }

    }

    enum SymbolConstants : int
    {
##SYMBOLS
##DELIMITER ','
        %ID.Padded% = %Value.Padded%%Delimiter% // %Description%
##END-SYMBOLS
    };

    enum RuleConstants : int
    {
##RULES
##DELIMITER ','
        %ID.Padded% = %Value.Padded%%Delimiter% // %Description%
##END-RULES
    };

##PARAMETERS
    public interface I%Name%Actions
##END-PARAMETERS
    {
##RULES
        void %ID% (Rule rule, Token [] tokens);
##END-RULES
    }

##PARAMETERS
    public class %Name%
##END-PARAMETERS
    {
        private LALRParser parser;
##PARAMETERS
        private I%Name%Actions actions;
##END-PARAMETERS

        private void ReduceEvent(LALRParser parser, ReduceEventArgs args)
        {
		    // By default, copy the user object from the first token on the rhs.  This will take
		    // care of most of the reductions, where we just pass the information along.
            if (args.Token.Tokens.Length >= 1)
            {
                args.Token.UserObject = args.Token.Tokens [0].UserObject;
            }
            
            switch (args.Token.Rule.Id)
            {
##RULES
                case (int)RuleConstants.%ID% :
                    // %Description%
                    actions.%ID% (args.Token.Rule, args.Token.Tokens);
                    return;

##END-RULES
            }
            throw new RuleException("Unknown rule");
        }

        private void AcceptEvent(LALRParser parser, AcceptEventArgs args)
        {
        }

        private void TokenErrorEvent(LALRParser parser, TokenErrorEventArgs args)
        {
            string message = "Token error with input: '"+args.Token.ToString()+"'";
            //todo: Report message to UI?
        }

        private void ParseErrorEvent(LALRParser parser, ParseErrorEventArgs args)
        {
            string message = "Parse error caused by token: '"+args.UnexpectedToken.ToString()+"'";
            //todo: Report message to UI?
        }

        private void Initialize (Stream stream)
        {
            CGTReader reader = new CGTReader (stream);
            parser = reader.CreateNewParser ();
            parser.TrimReductions = false; 
            parser.StoreTokens = LALRParser.StoreTokensMode.NoUserObject;

            parser.OnReduce += new LALRParser.ReduceHandler (ReduceEvent);
            parser.OnAccept += new LALRParser.AcceptHandler (AcceptEvent);
            parser.OnTokenError +=
                new LALRParser.TokenErrorHandler (TokenErrorEvent);
            parser.OnParseError +=
                new LALRParser.ParseErrorHandler (ParseErrorEvent);
        }

##PARAMETERS
        public %Name% (string filename)
##END-PARAMETERS
        {
            FileStream stream = new FileStream (filename,
                                                FileMode.Open, 
                                                FileAccess.Read, 
                                                FileShare.Read);
            Initialize (stream);
            stream.Close ();
        }

##PARAMETERS
        public %Name% (string baseName, string resourceName)
##END-PARAMETERS
        {
            byte[] buffer = ResourceUtil.GetByteArrayResource
               (System.Reflection.Assembly.GetExecutingAssembly (),
                baseName,
                resourceName);
            MemoryStream stream = new MemoryStream (buffer);
            Initialize (stream);
            stream.Close ();
        }

##PARAMETERS
        public %Name% (Stream stream)
##END-PARAMETERS
        {
            Initialize (stream);
        }

##PARAMETERS
        public void Parse (string source, I%Name%Actions a)
##END-PARAMETERS
        {
            actions = a;
            parser.Parse (source);
        }

    }
}
