##TEMPLATE-NAME 'C# - Calitha Engine, Interface Based'
##LANGUAGE 'C#'
##ENGINE-NAME 'Calitha GOLD Parser Engine'
##AUTHOR 'Pascal Leroy' 
##FILE-EXTENSION 'cs'
##NOTES
This template creates the constants for symbols and rules and a custom parser
class that acts as a template for parsing any source.  When a string is being
parsed, an object that implements the IActions interface is updated and it is
returned by the Parse method.  The code to deal with the reductions and other 
events must be provided by the class that implements IActions.
##END-NOTES
##ID-CASE UPPERCASE
##ID-SEPARATOR '_'
##ID-SYMBOL-PREFIX 'Symbol'
##ID-RULE-PREFIX 'Rule'

using com.calitha.commons;
using com.calitha.goldparser;
using com.calitha.goldparser.lalr;
using System;
using System.Diagnostics;
using System.IO;

##PARAMETERS
namespace %Name%
##END-PARAMETERS
{

    enum SymbolConstants : int
    {
##SYMBOLS
##DELIMITER ','
        %ID.Padded% = %Value.Padded%%Delimiter% // %Description%
##END-SYMBOLS
    };

    enum RuleConstants : int
    {
##RULES
##DELIMITER ','
        %ID.Padded% = %Value.Padded%%Delimiter% // %Description%
##END-RULES
    };

    public interface IActions
    {
##RULES
        void %ID% (Token token, Token [] tokens);
##END-RULES
    }

    public class Parser
    {
        private LALRParser parser;
        private IActions actions;

        private void ReduceEvent(LALRParser parser, ReduceEventArgs args)
        {
		    // By default, copy the user object from the first token on the rhs.  This will take
		    // care of most of the reductions, where we just pass the information along.
            if (args.Token.Tokens.Length >= 1)
            {
                args.Token.UserObject = args.Token.Tokens [0].UserObject;
            }
            
            switch (args.Token.Rule.Id)
            {
##RULES
                case (int)RuleConstants.%ID% :
                    // %Description%
                    actions.%ID% (args.Token, args.Token.Tokens);
                    return;

##END-RULES
            }
			Trace.Assert (false);
        }

        private void AcceptEvent(LALRParser parser, AcceptEventArgs args)
        {
        }

        private void TokenErrorEvent(LALRParser parser, TokenErrorEventArgs args)
        {
            string message = "Token error with input: '"+args.Token.ToString()+"'";
            //todo: Report message to UI?
        }

        private void ParseErrorEvent(LALRParser parser, ParseErrorEventArgs args)
        {
            string message = "Parse error caused by token: '"+args.UnexpectedToken.ToString()+"'";
            //todo: Report message to UI?
        }

        private void Initialize (Stream stream)
        {
            CGTReader reader = new CGTReader (stream);
            parser = reader.CreateNewParser ();
            parser.TrimReductions = false; 
            parser.StoreTokens = LALRParser.StoreTokensMode.NoUserObject;

            parser.OnReduce += new LALRParser.ReduceHandler (ReduceEvent);
            parser.OnAccept += new LALRParser.AcceptHandler (AcceptEvent);
            parser.OnTokenError +=
                new LALRParser.TokenErrorHandler (TokenErrorEvent);
            parser.OnParseError +=
                new LALRParser.ParseErrorHandler (ParseErrorEvent);
        }

        public Parser (string filename, IActions a)
        {
            FileStream stream = new FileStream (filename,
                                                FileMode.Open, 
                                                FileAccess.Read, 
                                                FileShare.Read);
            Initialize (stream);
            stream.Close ();
            actions = a;
        }

        public Parser (string baseName, string resourceName, IActions a)
        {
            byte[] buffer = ResourceUtil.GetByteArrayResource
               (System.Reflection.Assembly.GetExecutingAssembly (),
                baseName,
                resourceName);
            MemoryStream stream = new MemoryStream (buffer);
            Initialize (stream);
            stream.Close ();
            actions = a;
        }

        public Parser (Stream stream, IActions a)
        {
            Initialize (stream);
            actions = a;
        }

        public void Parse (string source)
        {
            parser.Parse (source);
        }

    }
}
