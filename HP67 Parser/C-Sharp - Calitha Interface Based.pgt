##TEMPLATE-NAME 'C# - Calitha Engine, Interface Based'
##LANGUAGE 'C#'
##ENGINE-NAME 'Calitha GOLD Parser Engine'
##AUTHOR 'Pascal Leroy' 
##FILE-EXTENSION 'cs'
##NOTES
This template creates the constants for symbols and rules and a custom parser
class that acts as a template for parsing any source.  When a string is being
parsed, an object that implements the IActions interface is updated and it is
returned by the Parse method.  The code to deal with the reductions and other 
events must be provided by the class that implements IActions.
##END-NOTES
##ID-CASE UPPERCASE
##ID-SEPARATOR '_'
##ID-SYMBOL-PREFIX 'Symbol'
##ID-RULE-PREFIX 'Rule'

using com.calitha.commons;
using com.calitha.goldparser;
using com.calitha.goldparser.lalr;
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;

##PARAMETERS
namespace %Name%
##END-PARAMETERS
{

    public enum SymbolConstants : int
    {
##SYMBOLS
##DELIMITER ','
        %ID.Padded% = %Value.Padded%%Delimiter% // %Description%
##END-SYMBOLS
    };

    enum RuleConstants : int
    {
##RULES
##DELIMITER ','
        %ID.Padded% = %Value.Padded%%Delimiter% // %Description%
##END-RULES
    };

    public interface IActions
    {
		void ParserAccept ();
        void ParserError (string input, TerminalToken token);
        string RemainingText
        {
			get;
        }
        bool Retry
        {
			get;
        }
        
##RULES
        void Reduce%ID% (string input, Token token, Token [] tokens);
##END-RULES
    }

    public class Parser
    {
		private static TraceSwitch classTraceSwitch = 
##PARAMETERS
			new TraceSwitch ("%Name%.Parser", "Automatically generated parser");
##END-PARAMETERS

        private IActions actions;
        private string input;
        private LALRParser parser;

        private void ReduceEvent(LALRParser parser, ReduceEventArgs args)
        {
			Trace.WriteLineIf (classTraceSwitch.TraceInfo,
				"ReduceEvent: reducing '" + args.Rule.ToString () + "'", 
				classTraceSwitch.DisplayName);
				
		    // By default, copy the user object from the first token on the rhs.  This will take
		    // care of most of the reductions, where we just pass the information along.
            if (args.Token.Tokens.Length >= 1)
            {
                args.Token.UserObject = args.Token.Tokens [0].UserObject;
            }
            
            switch (args.Token.Rule.Id)
            {
##RULES
                case (int)RuleConstants.%ID% :
                    // %Description%
                    actions.Reduce%ID% (input, args.Token, args.Token.Tokens);
                    return;

##END-RULES
            }
			Trace.Assert (false);
        }

        private void AcceptEvent(LALRParser parser, AcceptEventArgs args)
        {
			actions.ParserAccept ();
        }

        private void TokenErrorEvent(LALRParser parser, TokenErrorEventArgs args)
        {
			Trace.Assert (false);
        }

        private void ParseErrorEvent(LALRParser parser, ParseErrorEventArgs args)
        {
			actions.ParserError (input, args.UnexpectedToken);
        }

        public Parser (Reader reader, IActions a)
        {
            parser = reader.CreateNewParser ();
            parser.TrimReductions = false; 
            parser.StoreTokens = LALRParser.StoreTokensMode.NoUserObject;

            parser.OnReduce += new LALRParser.ReduceHandler (ReduceEvent);
            parser.OnAccept += new LALRParser.AcceptHandler (AcceptEvent);
            parser.OnTokenError += new LALRParser.TokenErrorHandler (TokenErrorEvent);
            parser.OnParseError += new LALRParser.ParseErrorHandler (ParseErrorEvent);
            actions = a;
        }

        public void Parse (string s)
        {
			Trace.WriteLineIf (classTraceSwitch.TraceInfo,
				"Parse: called with '" + s + "'",
				classTraceSwitch.DisplayName);

			input = actions.RemainingText + " " + s;

			Trace.WriteLineIf (classTraceSwitch.TraceInfo,
				"Parse: analyzing '" + input + "'",
				classTraceSwitch.DisplayName);

            parser.Parse (input);
            while (actions.Retry) {
				input = actions.RemainingText;

				Trace.WriteLineIf (classTraceSwitch.TraceInfo,
					"Parse: retrying analysis with '" + input + "'", 
					classTraceSwitch.DisplayName);
				
				parser.Parse (input);
            }
        }
        
    }
}
